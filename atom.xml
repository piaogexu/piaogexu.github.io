<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://piaogexu.github.io</id>
    <title>just do it </title>
    <updated>2021-08-13T09:07:06.972Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://piaogexu.github.io"/>
    <link rel="self" href="https://piaogexu.github.io/atom.xml"/>
    <subtitle>不知道要写什么，就随便写了。</subtitle>
    <logo>https://piaogexu.github.io/images/avatar.png</logo>
    <icon>https://piaogexu.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, just do it </rights>
    <entry>
        <title type="html"><![CDATA[通过修改PE文件加载DLL]]></title>
        <id>https://piaogexu.github.io/post/tong-guo-xiu-gai-pe-wen-jian-jia-zai-dll/</id>
        <link href="https://piaogexu.github.io/post/tong-guo-xiu-gai-pe-wen-jian-jia-zai-dll/">
        </link>
        <updated>2021-08-13T08:37:08.000Z</updated>
        <content type="html"><![CDATA[<h1 id="通过修改pe文件加载dll">通过修改PE文件加载DLL</h1>
<p>[toc]<br>
除了前面面所讲的 DLL 动态注入技术外，还可以采用“手工修改可执行文件”的方式加载用户指定的 DLL 文件。</p>
<h2 id="目标">目标</h2>
<p>这个实验的目标是：直接修改<code>TextView.exe</code>文件，使其在运行时自动加载<code>myhack.dll</code>文件。</p>
<h3 id="textviewexe">TextView.exe</h3>
<p><code>TextView.exe</code>是一个非常简单的文本查看程序，只要用鼠标将要查看的文本文件拖动（Drop）到其中，即可通过它查看文本文件的内容。如下</p>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2021/08/13/aHWAwzuB42ohNvE.png" alt="1.jpg" loading="lazy"></figure>
<p>使用 PEView 工具查看<code>TextView.exe</code>可执行文件的 <code>IDT</code>(<code>Import directory Table</code>,导入目录表)。</p>
<figure data-type="image" tabindex="2"><img src="https://i.loli.net/2021/08/13/bEhi3ZSzYKDaF2M.png" alt="2.jpg" loading="lazy"></figure>
<p>从上图可以看到，<code>TextView.exe</code>中直接导入的 DLL 文件为 <code>KERNEL32.dll</code> 、<code>USER32.dll</code>、 <code>GDI32.dll</code>、 <code>SHELL32.dll</code>。</p>
<h2 id="myhack32dll-源代码">myhack32.dll 源代码</h2>
<p>这一节用来分析 <code>myhack3.dll</code>的源代码。</p>
<pre><code>// dllmain.cpp : 定义 DLL 应用程序的入口点。
#include &quot;pch.h&quot;
#include &quot;stdio.h&quot;
#include &quot;windows.h&quot;
#include &quot;shlobj.h&quot;
#include &quot;Wininet.h&quot;
#include &quot;tchar.h&quot;

#pragma comment(lib, &quot;Wininet.lib&quot;)

#define DEF_BUF_SIZE  (4096)
#define DEF_URL L&quot;http://www.baidu.com/index.html&quot;
#define DEF_INDEX_FILE L&quot;index.html&quot;
HWND g_hWnd = NULL;


#ifdef __cplusplus
extern &quot;C&quot; {
#endif
    //  导出函数，但是没有任何功能，仅仅保持dll文件的形式上完整。
    __declspec(dllexport) void dummy()
    {
        return;
    }
#ifdef __cplusplus
}
#endif


//DownloadURL  下载 szURL 中指定网站的文件，并将其保存在 szFile 目录。
BOOL DownloadURL(LPCTSTR szURL, LPCTSTR szFile)
{
    BOOL            bRet = FALSE;
    HINTERNET	    hInternet = NULL, hURL = NULL;
    BYTE            pBuf[DEF_BUF_SIZE] = { 0, };
    DWORD           dwBytesRead = 0;
    FILE* pFile = NULL;
    errno_t         err = 0;

    hInternet = InternetOpen(L&quot;ReverseCore&quot;,
        INTERNET_OPEN_TYPE_PRECONFIG,
        NULL,
        NULL,
        0);
    if (NULL == hInternet)
    {
        OutputDebugString(L&quot;InternetOpen() failed!&quot;);
        return FALSE;
    }

    hURL = InternetOpenUrl(hInternet,
        szURL,
        NULL,
        0,
        INTERNET_FLAG_RELOAD,
        0);
    if (NULL == hURL)
    {
        OutputDebugString(L&quot;InternetOpenUrl() failed!&quot;);
        goto _DownloadURL_EXIT;
    }

    if (err = _tfopen_s(&amp;pFile, szFile, L&quot;wt&quot;))
    {
        OutputDebugString(L&quot;fopen() failed!&quot;);
        goto _DownloadURL_EXIT;
    }

    while (InternetReadFile(hURL, pBuf, DEF_BUF_SIZE, &amp;dwBytesRead))
    {
        if (!dwBytesRead)
            break;

        fwrite(pBuf, dwBytesRead, 1, pFile);
    }

    bRet = TRUE;

_DownloadURL_EXIT:
    if (pFile)
        fclose(pFile);

    if (hURL)
        InternetCloseHandle(hURL);

    if (hInternet)
        InternetCloseHandle(hInternet);

    return bRet;
}


BOOL CALLBACK EnumWindowsProc(HWND hWnd, LPARAM lParam)
{
    DWORD dwPID = 0;

    GetWindowThreadProcessId(hWnd, &amp;dwPID);

    if (dwPID == (DWORD)lParam)
    {
        g_hWnd = hWnd;
        return FALSE;
    }

    return TRUE;
}

HWND GetWindowHandleFromPID(DWORD dwPID)
{
    EnumWindows(EnumWindowsProc, dwPID);

    return g_hWnd;
}


//DropFile 函数将下载的 index.html 文件 拖到 TextView_Path.exe进程并显示其内容。
BOOL DropFile(LPCTSTR wcsFile)
{
    HWND            hWnd = NULL;
    DWORD           dwBufSize = 0;
    BYTE* pBuf = NULL;
    DROPFILES* pDrop = NULL;
    char            szFile[MAX_PATH] = { 0, };
    HANDLE          hMem = 0;

    WideCharToMultiByte(CP_ACP, 0, wcsFile, -1,
        szFile, MAX_PATH, NULL, NULL);

    dwBufSize = sizeof(DROPFILES) + strlen(szFile) + 1;

    if (!(hMem = GlobalAlloc(GMEM_ZEROINIT, dwBufSize)))
    {
        OutputDebugString(L&quot;GlobalAlloc() failed!!!&quot;);
        return FALSE;
    }

    pBuf = (LPBYTE)GlobalLock(hMem);

    pDrop = (DROPFILES*)pBuf;
    pDrop-&gt;pFiles = sizeof(DROPFILES);
    strcpy_s((char*)(pBuf + sizeof(DROPFILES)), strlen(szFile) + 1, szFile);

    GlobalUnlock(hMem);

    if (!(hWnd = GetWindowHandleFromPID(GetCurrentProcessId())))
    {
        OutputDebugString(L&quot;GetWndHandleFromPID() failed!!!&quot;);
        return FALSE;
    }

    PostMessage(hWnd, WM_DROPFILES, (WPARAM)pBuf, NULL);

    return TRUE;
}


DWORD WINAPI ThreadProc(LPVOID lParam)
{
    TCHAR szPath[MAX_PATH] = { 0, };
    TCHAR* p = NULL;

    OutputDebugString(L&quot;ThreadProc() start...&quot;);

    GetModuleFileName(NULL, szPath, sizeof(szPath));

    if (p = _tcsrchr(szPath, L'\\'))
    {
        _tcscpy_s(p + 1, wcslen(DEF_INDEX_FILE) + 1, DEF_INDEX_FILE);

        OutputDebugString(L&quot;DownloadURL()&quot;);
        if (DownloadURL(DEF_URL, szPath))
        {
            OutputDebugString(L&quot;DropFlie()&quot;);
            DropFile(szPath);
        }
    }

    OutputDebugString(L&quot;ThreadProc() end...&quot;);

    return 0;
}




BOOL APIENTRY DllMain( HMODULE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
                     )
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
        CloseHandle(CreateThread(NULL, 0, ThreadProc, NULL, 0, NULL));
        break;
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}
</code></pre>
<h3 id="dllmain">DllMain()</h3>
<pre><code>#include &quot;pch.h&quot;
#include &quot;stdio.h&quot;
#include &quot;windows.h&quot;
#include &quot;shlobj.h&quot;
#include &quot;Wininet.h&quot;
#include &quot;tchar.h&quot;

#pragma comment(lib, &quot;Wininet.lib&quot;)

#define DEF_BUF_SIZE  (4096)
#define DEF_URL L&quot;http://www.google.com/index.html&quot;
#define DEF_INDEX_FILE L&quot;index.html&quot;


DWORD WINAPI ThreadProc(LPVOID lParam)
{
    TCHAR szPath[MAX_PATH] = { 0, };
    TCHAR* p = NULL;

    OutputDebugString(L&quot;ThreadProc() start...&quot;);

    GetModuleFileName(NULL, szPath, sizeof(szPath));

    if (p = _tcsrchr(szPath, L'\\'))
    {
        _tcscpy_s(p + 1, wcslen(DEF_INDEX_FILE) + 1, DEF_INDEX_FILE);

        OutputDebugString(L&quot;DownloadURL()&quot;);
        if (DownloadURL(DEF_URL, szPath))
        {
            OutputDebugString(L&quot;DropFlie()&quot;);
            DropFile(szPath);
        }
    }

    OutputDebugString(L&quot;ThreadProc() end...&quot;);
    return 0;
}


BOOL APIENTRY DllMain( HMODULE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
                     )
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
        CloseHandle(CreateThread(NULL, 0, ThreadProc, NULL, 0, NULL));
        break;
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}
</code></pre>
<p><code>DLLMain()</code>函数的功能非常简单，创建线程运行指定的线程过程（ThreadProc） 中调用<code>DownloadURL()</code>与<code>DropFile()</code>函数。</p>
<h3 id="downloadurl">DownloadURL()</h3>
<pre><code>//DownloadURL  下载 szURL 中指定网站的文件，并将其保存在 szFile 目录。
BOOL DownloadURL(LPCTSTR szURL, LPCTSTR szFile)
{
    BOOL            bRet = FALSE;
    HINTERNET	    hInternet = NULL, hURL = NULL;
    BYTE            pBuf[DEF_BUF_SIZE] = { 0, };
    DWORD           dwBytesRead = 0;
    FILE* pFile = NULL;
    errno_t         err = 0;

    hInternet = InternetOpen(L&quot;ReverseCore&quot;,
        INTERNET_OPEN_TYPE_PRECONFIG,
        NULL,
        NULL,
        0);
    if (NULL == hInternet)
    {
        OutputDebugString(L&quot;InternetOpen() failed!&quot;);
        return FALSE;
    }

    hURL = InternetOpenUrl(hInternet,
        szURL,
        NULL,
        0,
        INTERNET_FLAG_RELOAD,
        0);
    if (NULL == hURL)
    {
        OutputDebugString(L&quot;InternetOpenUrl() failed!&quot;);
        goto _DownloadURL_EXIT;
    }

    if (err = _tfopen_s(&amp;pFile, szFile, L&quot;wt&quot;))
    {
        OutputDebugString(L&quot;fopen() failed!&quot;);
        goto _DownloadURL_EXIT;
    }

    while (InternetReadFile(hURL, pBuf, DEF_BUF_SIZE, &amp;dwBytesRead))
    {
        if (!dwBytesRead)
            break;

        fwrite(pBuf, dwBytesRead, 1, pFile);
    }

    bRet = TRUE;

_DownloadURL_EXIT:
    if (pFile)
        fclose(pFile);

    if (hURL)
        InternetCloseHandle(hURL);

    if (hInternet)
        InternetCloseHandle(hInternet);

    return bRet;
}
</code></pre>
<p><code>DownloadURL()</code>函数会下载参数<code>szURL</code>中指定的网页文件，并将其保存到<code>szFile</code>目录。</p>
<h3 id="dropfile">DropFile()</h3>
<pre><code>BOOL CALLBACK EnumWindowsProc(HWND hWnd, LPARAM lParam)
{
    DWORD dwPID = 0;

    GetWindowThreadProcessId(hWnd, &amp;dwPID);

    if (dwPID == (DWORD)lParam)
    {
        g_hWnd = hWnd;
        return FALSE;
    }

    return TRUE;
}

HWND GetWindowHandleFromPID(DWORD dwPID)
{
    EnumWindows(EnumWindowsProc, dwPID);

    return g_hWnd;
}


//DropFile 函数将下载的 index.html 文件 拖到 TextView_Path.exe进程并显示其内容。
BOOL DropFile(LPCTSTR wcsFile)
{
    HWND            hWnd = NULL;
    DWORD           dwBufSize = 0;
    BYTE* pBuf = NULL;
    DROPFILES* pDrop = NULL;
    char            szFile[MAX_PATH] = { 0, };
    HANDLE          hMem = 0;

    WideCharToMultiByte(CP_ACP, 0, wcsFile, -1,
        szFile, MAX_PATH, NULL, NULL);

    dwBufSize = sizeof(DROPFILES) + strlen(szFile) + 1;

    if (!(hMem = GlobalAlloc(GMEM_ZEROINIT, dwBufSize)))
    {
        OutputDebugString(L&quot;GlobalAlloc() failed!!!&quot;);
        return FALSE;
    }

    pBuf = (LPBYTE)GlobalLock(hMem);

    pDrop = (DROPFILES*)pBuf;
    pDrop-&gt;pFiles = sizeof(DROPFILES);
    strcpy_s((char*)(pBuf + sizeof(DROPFILES)), strlen(szFile) + 1, szFile);

    GlobalUnlock(hMem);

    if (!(hWnd = GetWindowHandleFromPID(GetCurrentProcessId())))
    {
        OutputDebugString(L&quot;GetWndHandleFromPID() failed!!!&quot;);
        return FALSE;
    }

    PostMessage(hWnd, WM_DROPFILES, (WPARAM)pBuf, NULL);

    return TRUE;
}
</code></pre>
<p><code>DropFile()</code>函数将下载的<code>index.html</code>文件拖到<code>TextView_Patch.exe</code>进程并显示其内容。</p>
<h3 id="dummy">dummy()</h3>
<pre><code>#ifdef __cplusplus
extern &quot;C&quot; {
#endif
    //  导出函数，但是没有任何功能，仅仅保持dll文件的形式上完整。
    __declspec(dllexport) void dummy()
    {
        return;
    }
#ifdef __cplusplus
}
#endif
</code></pre>
<p><code>dummy()</code>导出函数，但是没有任何功能，仅仅保持dll文件的形式上完整。</p>
<p>在PE文件中导入某个 DLL ，实质就是在文件代码内调用该 DLL 提供的导出函数。PE 文件头中记录着 DLL 名称、函数名称等信息。因此，<code>myhack3.dll</code>至少需要向外提供一个以上的导出函数才能保持形式上的完整性。</p>
<h2 id="修改textviewexe-文件的准备工作">修改TextView.exe 文件的准备工作</h2>
<h3 id="修改思路">修改思路</h3>
<p>PE文件中导入的 dll 信息以结构体列表的形式存储在 IDT 中。重要将 myhack3.dll 添加到列表尾部就可以了。 当然，此前需要确认一下 IDT 中有无足够的空间。</p>
<h3 id="查看idt-是否有足够的空间">查看IDT 是否有足够的空间</h3>
<p>首先，使用 PEView 查看 TextView.exe  的 IDT 地址（PE 文件头的 IMAGE_OPTIONAL_HEADER 结构体中导入表 RVA 值即为 IDT 的RVA值）。</p>
<p>从下图可以看出，IDT 的地址（RVA）为 84CC 。 接下来在 PEView 中直接查看 IDT （在 PEView<br>
工具栏中设置地址视图选项为 RVA ）。</p>
<figure data-type="image" tabindex="3"><img src="https://i.loli.net/2021/08/13/AWtKaOLnecZl53M.png" alt="3.jpg" loading="lazy"></figure>
<p>从上图可以看出，TextView.exe 的 IDT 存在与 <code>.rdata</code> 节区。 IDT 是由 <code>IMAGE_IMPORT_DESCRIPTOR</code>(以下简称 IID) 结构体组成的数组，且数组的末尾以 NULL 结构体结束。由于每个导入的 DLL 文件都对应 1 个 IID 结构体（每个 IID 结构体的大小为 0<code>*1</code>4字节），所以下图中的整个 IID 区域为RVA：84CC ~ 852F(整体大小为：0<code>*</code>14<code>*</code>5 = 0<code>*</code>64字节)</p>
<figure data-type="image" tabindex="4"><img src="https://i.loli.net/2021/08/13/VgfXsP5wltqkIBa.png" alt="4.jpg" loading="lazy"></figure>
<p>IID 结构体的定义</p>
<pre><code>IMAGE_IMPORT_DESCRIPTOR

typedef struct _IMAGE_IMPORT_DESCRIPTOR
{
    union{
        DWORD Characteristics;
        DWOED OriginalFirstThunk;   //RVA to INT(Import Name Table)
    };                          
    DWORD   TimeDataStamp;
    DWORD   ForwarderChain;         
    DWORD   Name;                   //RVA to DLL Name String    
    DWORD   FirstThunk;             //RVA to IAT(Import Address Table)
}IMAGE_IMPORT_DESCRIPTOR;
</code></pre>
<p>在 PEView 工具栏将视图改为 File Offset，可以看到 IDT 的文件偏移为 76CC，如下图所示</p>
<figure data-type="image" tabindex="5"><img src="https://i.loli.net/2021/08/13/pFNLn2CkUitDXQs.png" alt="5.jpg" loading="lazy"></figure>
<p>使用 HxD 使用工具打开 TextView文件，找到 76CC 地址，如下图所示</p>
<figure data-type="image" tabindex="6"><img src="https://i.loli.net/2021/08/13/m7DOYdT3CRfqy2F.png" alt="6.jpg" loading="lazy"></figure>
<p>IDT 的文件偏移为 76CC ~ 772F ，整个大小为64字节，共有5个 IID 结构体，其中最后一个为 NULL<br>
结构体。从图中可以看出 IDT 尾部存在其它数据，没有足够的空间来添加 myhack3.dll 的 IID 结构体。</p>
<h3 id="移动-idt">移动 IDT</h3>
<p>在这种情况下，我们首先要把整个 IDT 转移到其他更广阔的位置。然后在添加新的 IID。确定移动的目标位置时，可以使用下面三种方式：</p>
<ul>
<li>查找文件中大的空白区域</li>
<li>增加文件最后一个节区的大小</li>
<li>在文件末尾添加新的节区</li>
</ul>
<p>首先第一种，即查找文件中的空白区域（程序运行时未使用的区域）。正如下图所示，<code>.rdata</code>节区尾部恰好存在大片空白区域（一般来说，节区或文件末尾都存在空白区域，PE 文件中这种空白区域称为 Null-Padding 区域）。</p>
<figure data-type="image" tabindex="7"><img src="https://i.loli.net/2021/08/13/TCzs4rDy6xWNE7g.png" alt="7.jpg" loading="lazy"></figure>
<p>下面，就需要把原来的 IDT 移动到该 Null-Padding 区域（RVA：8C60 ~ 8DFF）中合适的位置即可。在此之前需要确认一下该区域（RVA：8C60 ~ 8DFF）是否是空白空用区域（Null-Padding区域）。</p>
<p>需要注意的是，并不是文件中所有区域都会被无条件加载到进程的虚拟内存，只有节区头中明确记录的区域才会被加载。使用 PEView 工具查看 TextView.exe 文件的 <code>.rdata</code> 节区头，如下所示：</p>
<figure data-type="image" tabindex="8"><img src="https://i.loli.net/2021/08/13/BHSfn3EdA9VuX4g.png" alt="8.jpg" loading="lazy"></figure>
<p>节区头中存储着对应节区的位置，大小，属性等信息。整理<code>.rdata</code>节区头中信息，如下表所示</p>
<table>
<thead>
<tr>
<th>条目</th>
<th>值</th>
<th>注释</th>
</tr>
</thead>
<tbody>
<tr>
<td>Pointer to Raw Data</td>
<td>5200</td>
<td>[文件]节区起始位置</td>
</tr>
<tr>
<td>Size of Raw Data</td>
<td>2E00</td>
<td>[文件]节区大小</td>
</tr>
<tr>
<td>RVA</td>
<td>6000</td>
<td>[内存]节区起始位置</td>
</tr>
<tr>
<td>Virtual Size</td>
<td>2C56</td>
<td>[内存]节区大小</td>
</tr>
</tbody>
</table>
<p>从节区头中信息可以看出，<code>.rdata</code>节区在磁盘文件与内存中的大小是不同的。</p>
<p><code>.rdata</code> 节区在磁盘文件中的大小为 <code>2E00</code>,而文件执行后被加载到内存时，程序实际使用的数据大小（映射大小）仅为 2C56 ，剩余未被使用的区域大小为 1AA （2E00 - 2C56）。在这段空白区域创建 IDT 是不会有什么问题的。</p>
<p>空白区域<br>
RVA：8C56 - 8E00   --&gt; RAW : 7E56 - 8000</p>
<p>故下图的 Null-Padding 区域是可以使用的，接下来我们在 RVA：8C80（RAW：7E80）位置创建 IDT。</p>
<figure data-type="image" tabindex="9"><img src="https://i.loli.net/2021/08/13/7WJV6EhqXfnkt3l.png" alt="9.jpg" loading="lazy"></figure>
<h2 id="修改textviewexe">修改TextView.exe</h2>
<p>先把 TextView.exe 复制到工作文件夹，重命名为<code>TextView_Patch.exe</code>。下面使用<code>TextView_Patch.exe</code>文件进行练习打补丁。基本操作步骤是：先使用 PEView 打开 TextView.exe 原文件，查看各种 PE 信息，然后使用 HxD 打开 TextView_Patch 文件进行修改。</p>
<h3 id="修改导入表的rva值">修改导入表的RVA值</h3>
<p><code>IMAGE_OPTIONAL_HEADERD</code>的导入表结构体成员用来指出 IDT 的位置（RVA）与大小，如下所示</p>
<figure data-type="image" tabindex="10"><img src="https://i.loli.net/2021/08/13/2fcxjaQ3DBX19Ei.png" alt="10.jpg" loading="lazy"></figure>
<p>TextView.exe 文件中，导入表的 RVA 值为 84CC 。接下来，将导入表的 RVA 值更改为新 IDT 的 RVA 值 8C80,在 Size 原值64字节的基础上再加 14字节（IID 结构体的大小），修改为78字节，如下所示。</p>
<figure data-type="image" tabindex="11"><img src="https://i.loli.net/2021/08/13/Ee1xp8y57JBajLG.png" alt="11.jpg" loading="lazy"></figure>
<p>从现在开始，导入表位于 RVA: 8C80(RAW : 7E80)地址出。</p>
<h3 id="删除导入表">删除导入表</h3>
<p><code>BOUND IMPORT TABLE</code>(绑定导出表)是一种提高 DLL 加载速度的技术，如下</p>
<figure data-type="image" tabindex="12"><img src="https://i.loli.net/2021/08/13/4TZVzafoWYgS9lQ.png" alt="12.jpg" loading="lazy"></figure>
<p>若向正常导入 myhack3.dll ，需要向绑定导入表添加信息。但是幸运的是，该绑定导入表是个可选选项，不是必须存在的，所以可以删除（修改其值为 0 即可）以获取更大便利。当然绑定导入表完全不存在也没有关系，但若存在，且其内信息记录错误，则会在程序运行时引发错误。本示例 TextView.exe  文件中，绑定导入表各项的值均为 0 ，不需要再修改。修改文件时，一定要注意检查绑定导入表中的数据。</p>
<h3 id="创建新-idt">创建新 IDT</h3>
<p>先使用 Hex Editor 完全复制原 IDT（RAW:76CC ~ 772F）,然后覆写（Past write）到 IDT 的新位置（RAW ：7E80 ），如下图所示</p>
<figure data-type="image" tabindex="13"><img src="https://i.loli.net/2021/08/13/bynhmUiRXSEgdI1.png" alt="13.jpg" loading="lazy"></figure>
<p>然后在新的IDT 尾部（RAW：7ED0）添加与 myhack3.dll 对应的 IID （后面会单独讲解各个成员的数据）</p>
<pre><code>//IMAGE_IMPORT_DESCRIPTOR
typedef struct _IMAGE_IMPORT_DESCRIPTOR{
    union{
        DWORD Characteristics;
        DWORD OriginalFirstThunk;   //00008D00  =&gt; RVA to INT
    };
    DWORD   TimeDataStamp;          //0
    DWORD   ForwarderChain;         //0
    DWORD   Name;                   //00008D10  =&gt; RVA to DLL Name
    DWORD   FirstThunk;             //00008D20  =&gt; RVA to IAT
} IMAGE_IMPORT_DESCRIPTOR;
</code></pre>
<p>在准确位置（RAW：7ED0）写入相关数据，如下所示</p>
<figure data-type="image" tabindex="14"><img src="https://i.loli.net/2021/08/13/w4a6qpYScrgPsOu.png" alt="14.jpg" loading="lazy"></figure>
<h3 id="设置name-int-iat">设置Name、INT、IAT</h3>
<p>前面添加的 IID 结构体成员拥有指向其他数据结构（INT、Name、IAT）的RVA值。因此，必须准确设置这些数据结构才能保证 TextView_Patch.exe 文件的正常运行。由前面的设置可知 INT、Name、IAT的 RVA/RAW 的值整理如下</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>RVA</th>
<th>RAW</th>
</tr>
</thead>
<tbody>
<tr>
<td>INT</td>
<td>8D00</td>
<td>7F00</td>
</tr>
<tr>
<td>Name</td>
<td>8D10</td>
<td>7F10</td>
</tr>
<tr>
<td>IAT</td>
<td>8D20</td>
<td>7F20</td>
</tr>
</tbody>
</table>
<p>这些地址（RVA：8D00，8D10，8D20）就位于新建的IDT（RVA：8C80）下方。当然也可以选择其他符合条件的区域。在 HxD 编辑器中转到 7F00  地址处，输入相应值，如下图所示</p>
<figure data-type="image" tabindex="15"><img src="https://i.loli.net/2021/08/13/U2kmHRwtfjXhVpM.png" alt="15.jpg" loading="lazy"></figure>
<p>为了更好地理解以上内容，使用 PEView 打开 TextView_Patch.exe 文件查看同一区域，查看时使用 RVA 视图方式，如下所示</p>
<figure data-type="image" tabindex="16"><img src="https://i.loli.net/2021/08/13/ibRglsdEWoGxpMJ.png" alt="16.jpg" loading="lazy"></figure>
<p>8CD0地址处存在着 myhack3.dll 的结构体，其中3各主要成员（RVA of INT 、RVA of Name、RVA of IAT）的值分别时实际 INT 、Name、IAT的指针。</p>
<p>简单来说，INT（Import Name Table，导入名称表）是 RVA 数组，数组的各个元素都是一个 RVA 地址，该地址由导入函数的 Ordinal（2个字节）+ Func Name String 结构体构成，数组的末尾为 NULL。 上图中 INT 有一个元素，其值为 8D30，该地址是要导入的函数的 Ordinal（2字节）与函数的名称字符串（“dummy”）。</p>
<p>Name 是包含导入函数的 DLL 文件名称字符串，在 8D10 地址处可以看到<code>myhack3.dll</code>字符串。</p>
<p>IAT 也是RVA 数组，各元素既可以拥有与 INT 相同的值，也可以拥有其他不用的值（若 INT 中的数据准确，IAT 也可以拥有其他不同值）。反正实际运行时，PE 装载器会将虚拟内存中的 IAT 替换为实际函数的地址</p>
<h3 id="修改-iat-节区的属性值">修改 IAT 节区的属性值</h3>
<p>加载 PE 文件到内存时，PE装载器会修改 IAT ，写入函数的实际地址，所以相关节区一定要拥有 WRITE（可写）属性。只有这样，PE 装载器才能正常进行写入操作。使用 PEView查看<code>.rdata</code>节区头，如下所示</p>
<figure data-type="image" tabindex="17"><img src="https://i.loli.net/2021/08/13/SliFt6GLvqN3K9k.png" alt="17.jpg" loading="lazy"></figure>
<p>向原属性（ChAracteristics）40000040 添加 IMAGE_SCN_MEM_WRITE(80000000)属性值，执行 bit OR 运算，最终属性值变为 C0000040 ， 如下图所示</p>
<figure data-type="image" tabindex="18"><img src="https://i.loli.net/2021/08/13/Rl5ib7ur6UVPpyT.png" alt="18.jpg" loading="lazy"></figure>
<h3 id="检测验证">检测验证</h3>
<p>首先使用 PEView 工具打开修改后的 TextView_Patch.exe 文件，查看其 IDT ，如下所示</p>
<figure data-type="image" tabindex="19"><img src="https://i.loli.net/2021/08/13/3H5j897aYw2oKk4.png" alt="19.jpg" loading="lazy"></figure>
<p>向 IDT 导入 myhack3.dll 的 IID 结构体已设置正常。如下所示， myhack3.dll 的 dummy() 函数被添加到 INT。</p>
<figure data-type="image" tabindex="20"><img src="https://i.loli.net/2021/08/13/MompvFtRqg72ely.png" alt="20.jpg" loading="lazy"></figure>
<p>从文件结构来说修改成功，接下来运行文件看看程序是否能正常运行。将TextView_Patch.exe和myhack3.dll 放入相同文件夹，然后运行 TextView_Patch.exe 文件，结果如下所示：</p>
<figure data-type="image" tabindex="21"><img src="https://i.loli.net/2021/08/13/qxdOhFHoNCtQ4S8.png" alt="21.jpg" loading="lazy"></figure>
<p>可以看见 TextView_Patch.exe 成功加载了 myhack.dll 文件并下载了指定网站的 index.html 文件，并在 TextView_Patch.exe 中显示。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[UPack的头文件分析]]></title>
        <id>https://piaogexu.github.io/post/upack-de-tou-wen-jian-fen-xi/</id>
        <link href="https://piaogexu.github.io/post/upack-de-tou-wen-jian-fen-xi/">
        </link>
        <updated>2021-08-06T01:31:08.000Z</updated>
        <content type="html"><![CDATA[<p>UPack的头文件分析</p>
<h2 id="重叠头文件">重叠头文件</h2>
<p>由于PE View 打开文件会出现bug，使用Stud_PE工具打开经过UPack压缩之后的文件。</p>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2021/08/06/s2jdo57QNt4GcyA.png" alt="21.png" loading="lazy"></figure>
<p>mz文件头（IMAGE_DOS_HEADER）中有以下两个重要成员：</p>
<pre><code>(offset 0)  e_magic :   Magic number = 4D5A('MZ')
(offset 3C) e_lfanew:   File address of new exe header
</code></pre>
<p><code>e_lfanew</code>指出了PE头的便宜位置即<code>IMAGE_NT_HHEADERS</code>的起始位置。<code>IMAGE_NT_HHEADERS</code>的起始位置是可以变的。正常情况下</p>
<pre><code>e_lfanew = MZ头文件大小（40） + DOS存根大小（可变：VC++下为A0）
</code></pre>
<p>UPack中的<code>e_lfanew</code>的值为10，这部违反PE的规范，只是钻了空子，这样MZ文件头和PE文件头就重叠到一起了。</p>
<h3 id="image_file_headersizeofoptionalheader">IMAGE_FILE_HEADER.SizeOfOptionalHeader</h3>
<p>修改<code>IMAGE_FILE_HEADER.SizeOfOptionalHeader</code>的值，可以向头文件插入解压代码。<br>
<code>IMAGE_FILE_HEADER.SizeOfOptionalHeader</code>的值用来指出<code>IMAGE_OPTIONAL_HEADER</code>结构体的长度。</p>
<figure data-type="image" tabindex="2"><img src="https://i.loli.net/2021/08/06/sXcEk2LfaPKlqm8.png" alt="20M0T9EW_E_Y1_6HPUR_T.png" loading="lazy"></figure>
<p>在PE32文件中 <code>IMAGE_OPTIONAL_HEADER</code> 的结构体大小为<code>E0</code>，此处的<code>SizeOfOptionalHeader</code>为148。</p>
<p>故节区头<code>IMAGE_SECTION_HEADER</code>的的起始位置为 170 （<code>IMAGE_OPTIONAL_HEADER</code>的起始位置偏移（28）+ <code>SizeOfOptionalHeader</code>（148） = 170）</p>
<p><code>IMAGE_OPTIONAL_HEADER</code>结束的位置为 D7 ，<code>IMAGE_SECTION_HEADER</code>的起始位置为 170，查看中间位置，如下所示：</p>
<figure data-type="image" tabindex="3"><img src="https://i.loli.net/2021/08/06/V5DBuIrRoCSscWK.png" alt="_2YC_X48QG`IZ0AEI_DI1_5.png" loading="lazy"></figure>
<p>此处是UPack代码。而不是PE头文件信息。使用PE相关的工具对其进行识别为PE文件信息，就会引发错误，导致程序无法运行。</p>
<h3 id="image_optional_headernumberofrvaandsizes">IMAGE_OPTIONAL_HEADER.NumberOfRvaAndSizes</h3>
<p><code>NumberOfRvaAndSizes</code>用来指定<code>DataDirectory</code>（<code>IMAGE_OPTIONAL_HEADER32</code>结构体的最后一个成员）数组的个数。PE装载器通过查看<code>NumberOfRvaAndSizes</code>的值来识别数组的大小，换而言之数组的大小也可能不是16。</p>
<figure data-type="image" tabindex="4"><img src="https://i.loli.net/2021/08/06/Rpf9Vv3Kdque1mx.png" alt="_7_N_C6L_BIUO5N0HXJ26GC.png" loading="lazy"></figure>
<p><code>IMAGE_DATA_DIRECTORY</code>结构体的数组元素个数已经固定为 10（16进制的10等于十进制的16），但是由于UPack将<code>NumberOfRawAndSize</code>的值作为数组元素的个数。<code>IMAGE_DATA_DIRECTORY</code>结构体数组的后6个元素被忽略。</p>
<h3 id="image_section_header">IMAGE_SECTION_HEADER</h3>
<p><code>IMAGE_SECTION_HEADER</code>结构体中，UPack会。把自身数据记录到程序运行不需要的项目。这与UPack向PE文件头中不使用的区域覆写自身代码与数据的方法是一样的。</p>
<p><code>IMAGE_SECTION_HEADER</code>结构体中对程序运行没有意义的选项为：</p>
<pre><code>DWORD PointerTORelocations;
DWORD PoterToLinenumbers;
WORD NumberOfRelocations;
WORD NumberOfLinenumbers;
</code></pre>
<h3 id="重叠节区">重叠节区</h3>
<p>UPack的主要特征就是可以随意重叠PE节区与头文件。</p>
<p>使用Stud_PE提供的简略试图查看UPack的<code>IMAGE_SECTION_HEADER</code>。</p>
<figure data-type="image" tabindex="5"><img src="https://i.loli.net/2021/08/06/DQra2NlIyYMRzH1.png" alt="_M_W0ZAKT2@4DN6_TMTF`76.png" loading="lazy"></figure>
<p>第一个节区与第三个节区的文件起始偏移（RawOffset）值都为10。便宜10是头文件区域，UPack中该位置起即为字节区域。</p>
<p>第一个节区和第三个节区的起始文件偏移（RawOffset）与在文件中的大小（RawSize）是完全一直的。但是节区内存的起始RVA（VirtualOffset）项与内存大小（VirtualSize）值是不一样的。</p>
<p>综上所示：UPack会对PE文件头、第一个节区、第三个节区进行重叠。</p>
<p>根据节区头（<code>IMAGE_SECTION_HEADER</code>）中定义的值，PE装载器会将文件偏移 0~1FF 的区域分别映射到3个不同的内存位置（文件头、第一个节区、第三个节区）。也就是说，用相同的文件映像可以分别创建出处于不同位置的、大小不同的内存映像。</p>
<p>文件的头（第一个节区/第三个节区）区域大小为200，其实这是非常小的。相反第二个节区（2nd Section）尺寸（AE28）非常大，占据了文件的大部分区域，源文件（notepad.exe）即压缩在此。</p>
<p>另一个需要注意的是内存中的第一个节区区域，它的内存尺寸大小为1400，与原文件（notepad.exe）的SizeImage具有相同的值，也就是说，压缩在第二个节区中的文件映像会被原样解压缩到第一个节区（notepad.exe的内存映像）。另外，元notepa.exe拥有的三个节区，它们被解压到一个节区。</p>
<h3 id="总结">总结</h3>
<p>压缩的notepad.exe在内存的第二个节区，解压缩的同时被记录到第一个节区。重要的是，notepad.exe(源文件)的内存映射会被整体解压，所以程序能够正常运行（地址变的准确而一致）。</p>
<h3 id="rva-to-raw">RVA to RAW</h3>
<p>各种PE实用程序对UPack束手无策的原因就是无法正确进行 RVA -&gt; RAW 的变换。</p>
<p>RVA -&gt; RAW 公式为</p>
<pre><code>RAW = RVA - VirtualAddress + PointerTORawData

VirtualAddress、PointerToRawData 是从RAW所在的节区头中获取的值，它们都是已知的值（Known value）。
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://i.loli.net/2021/08/06/W6KGkoV1tAvxTyI.png" alt="4UIABBI42125Q8`_RD_ADT1.png" loading="lazy"></figure>
<p>根据上述公式算一下EP 的文件偏移量（RAW） ， UPack的EP是 RVA 1018 。</p>
<figure data-type="image" tabindex="7"><img src="https://i.loli.net/2021/08/06/TFY4HoqOGncpdxX.png" alt="I_0AU_U9__H5_CRCQ_NS.png" loading="lazy"></figure>
<pre><code>RAW = RVA - 1000 + 10 = 28
</code></pre>
<p>使用 Hex Editor 打开 RAW 28 区查看</p>
<figure data-type="image" tabindex="8"><img src="https://i.loli.net/2021/08/06/5IGxPMRUl6KF1Vd.png" alt="V1OHP1_3N_7TS3REM0KYG.png" loading="lazy"></figure>
<p>RAW 28 区 不是代码区，而是（Ordinal：010B）&quot;loadLibraryA&quot;字符串区域。</p>
<p>出现这样的情况是因为 第一个节区的PointerToRawData值为10。</p>
<p>一般而言，指向节区开始的文件偏移的 <code>PointerToRawData</code>值应该是<code>FileAlignment</code>的整数倍。UPack的<code>FileAlignment</code>为200，故<code>PointerToRawData</code>值应为0、200、400、600等值。PE装载器发先第一个节区的<code>PointerToRawData（10）</code>不是<code>FileAlignment（200）</code>的整数倍时，它会强制将其识别为整数倍（该情况下为0）.这使得UPack文件能够正常运行，但是许多PE相关实用程序都会发生错误。</p>
<h3 id="导入表">导入表</h3>
<p>要在Hex Editor 查看 <code>IMAGE_IMPORT_DESCRIPTOR</code>结构体，首先要从<code>Directory Table</code>中获取 IDT（IMAGE_IMPORT_DESCRIPTOR结构体数组）的地址</p>
<figure data-type="image" tabindex="9"><img src="https://i.loli.net/2021/08/06/jq2DtrWmk1unSlQ.png" alt="UV_3PF6Q_IXAZPUN7B__`QR.png" loading="lazy"></figure>
<p>右侧的8个字节大小的data就是指向导入表的<code>IMAGE_DATA_DIRECTORY</code>结构体。前面四个字节为导入表的地址（RVA:271EE）。后面四个字节的大小时导入表的大小（Size(14h)）</p>
<figure data-type="image" tabindex="10"><img src="https://i.loli.net/2021/08/06/3VWOhkdlQ6zrPUq.png" alt="A3BB__DZ42X2_8JA__IJR6Q.png" loading="lazy"></figure>
<p>RVA -&gt; RAW 变换</p>
<pre><code>RAW = RVA(271EE) - VirtualOfSet(27000) + RawOffset(0)
    = 1EE
</code></pre>
<p>使用Hex Editor 查看文件偏移</p>
<figure data-type="image" tabindex="11"><img src="https://i.loli.net/2021/08/06/ZpdXfcFq61E5nrj.png" alt="U`G_6N3@I0C3U5XBFS_Z6OQ.png" loading="lazy"></figure>
<p>根据 PE 规范 导入表是由一系列<code>IMAGE_IMPORT_DESCRIPTOR</code>结构体组成的数组，最后以一个内容为NULL的结构体结束。</p>
<p>上图 咋一看违反了 PE 规范，但是注意红线，该条线表示文件中第三个节区的结束。故运行时偏移在200以下的本部分不会映射到第三个节区内存。故第三个节区加载到内存时，文件偏移0<sub>1FF的区域映射到内存的27000</sub>271FF区域，而（第三个节区其余的内存区域）27000~28000区域全部填充为NULL。</p>
<h3 id="导入地址表">导入地址表</h3>
<p>通过上图得到映射关系</p>
<pre><code>IMAGE_IMPORT_DESCRIPTOR (20字节)

偏移        成员                                 RVA
1EE    OriginalFirstThunk（INT）(0-3字节)         0
1FA         Name(12-15字节)                       2
1FE    FirstThunk（IAT）(16-19字节)              11E8
</code></pre>
<p>Name的RVA值为2，它属于Header区域，在Header区域 RVA与RAW是一样的。</p>
<figure data-type="image" tabindex="12"><img src="https://i.loli.net/2021/08/06/hKxdSQOilDMwGAy.png" alt="TIZC_~__B39QG_A__935TRI.png" loading="lazy"></figure>
<p>可以看见UPack将 Import DLL 写到了该处。</p>
<p>IAT的RVA值为 11E8 故在第一个节区</p>
<figure data-type="image" tabindex="13"><img src="https://i.loli.net/2021/08/06/djwY276xL9cBZfS.png" alt="ZFUYMDD2E_R_7R3_APNNX`C.png" loading="lazy"></figure>
<pre><code>RVA -&gt; RAW
RAW = RVA(11E8) - VirtualOffset(1000) + RawOffset(0) = 1E8 
</code></pre>
<figure data-type="image" tabindex="14"><img src="https://i.loli.net/2021/08/06/bYzoEt4NvUnqVX3.png" alt="2ZT`__4@F_I1UPPRU___I_4.png" loading="lazy"></figure>
<p>可以看见此处有导入了两个API，分别是 RVA 28 与 BE 。</p>
<p>都是header区域，所以 RVA=RAW，如下</p>
<figure data-type="image" tabindex="15"><img src="https://i.loli.net/2021/08/06/I9eWncP5qkVEjBF.png" alt="JZ_6QJHQD8KN5N9M5U81F94.png" loading="lazy"></figure>
<figure data-type="image" tabindex="16"><img src="https://i.loli.net/2021/08/06/oYX15keBHANWV6I.png" alt="W1O@__HPP1SMTD2I0JCXWHQ.png" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PE文件详解]]></title>
        <id>https://piaogexu.github.io/post/pe-wen-jian-xiang-jie/</id>
        <link href="https://piaogexu.github.io/post/pe-wen-jian-xiang-jie/">
        </link>
        <updated>2021-08-04T09:42:04.000Z</updated>
        <content type="html"><![CDATA[<h1 id="pe文件">PE文件</h1>
<h3 id="介绍">介绍</h3>
<p>PE文件是windows操作系统下使用的可执行文件格式。它是微软在UNIX平台的COFF（Common Object File Format，通用对象文件格式）基础上制作而成的，最初（正如Portable这个单词所代表的那样）设计用来提高程序在不同操作系统上的移植性 ，但实际上这种文件格式仅用在windows系列的操作系统下。</p>
<p>PE文件是指32位的可执行文件，也称为PE32。64位的可执行文件称为PE+或者PE32+，是（PE32）文件的一种扩展形式。</p>
<h2 id="pe文件格式">PE文件格式</h2>
<p><strong>PE文件种类</strong></p>
<table>
<thead>
<tr>
<th>种类</th>
<th>主扩展名</th>
</tr>
</thead>
<tbody>
<tr>
<td>可执行系列</td>
<td>EXE、SCR</td>
</tr>
<tr>
<td>库系列</td>
<td>DLL、OCX、CPL、DRV</td>
</tr>
<tr>
<td>驱动程序系列</td>
<td>SYS、VXD</td>
</tr>
<tr>
<td>对象文件系列</td>
<td>OBJ</td>
</tr>
</tbody>
</table>
<p>严格地说，OBJ（对象）文件之外的所有文件都是可执行的。DLL、SYS文件等虽然不能直接在Shell（Explorer.exe）中运行，但可以使用其它方法（调试器、服务等）执行。</p>
<p>下面以记事本（notepad.exe）程序进行简单的说明，首先使用Hex Editor打开记事本程序。</p>
<p>下图是notepad.exe文件的起始部分，也是PE文件的头部份（PE header）。notepad.exe 文件运行需要的所有信息就存储在这个 PE 头中。如何加载到内存、从何处开始运行、运行中需要的DLL有哪些、需要多大的栈/堆内存等，大量信息以结构体形式存储在PE头中。换而言之，学习PE文件格式就是学习PE头中的结构体。</p>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2021/08/04/plnfGmVXhtDWaY1.png" alt="1628070204_1_.jpg" loading="lazy"></figure>
<h3 id="基本结构">基本结构</h3>
<p>notepad.exe 具有普通PE文件的基本结构。</p>
<p>从DOS头（DOS header）到节区头（Section header）是PE头文件，其下的节区合称PE体。文件中使用偏移（offset），内存中使用VA（Virtual address，虚拟地址）来表示位置。文件加载到内存时，情况就会发生变化（节区大小、位置等）。文件的内容一般可以分为代码（.test）、数据（.data）、资源（.rsrc）节，分别保存。</p>
<p>各节区头定义了各节区在文件或内存中的大小、位置、属性等。</p>
<p>PE头与节区的尾部存在一个区域，称为NULL填充（NULL padding）。计算机中，为了提高处理文件、内存、网络包的效率，使用“最小基本单位”这一单位，PE文件中也类似。文件/内存中节区的起始位置应该在个文件/内存最小单位的倍数位置上，空白区域将在NULL填充。</p>
<h3 id="vaerva">VA&amp;ERVA</h3>
<p>VA指的是进程虚拟内存的绝对地址，RVA（Relative Virtual Address，相对虚拟地址）指从某个基准位置（ImageBase）开始的相对地址。VA与RVA满足下面关系：</p>
<pre><code>            RVA+ImageBase=VA
</code></pre>
<p>PE头文件信息大多以RVA形式存在。原因在于，PE文件（主要是DLL）加载到进程虚拟内存的特定位置时，该位置可能已加载了其他PE文件（DLL）。此时必须通过重定位（Relocation）加载到其他空白的位置，若PE头信息使用的是VA，则无法正常访问，因此使用RVA来定位信息，即使发生了重定位，只要相对基准位置的相对地址没有变化，就能正常访问到指定信息，不会出现任何问题。</p>
<h2 id="pe头">PE头</h2>
<h3 id="dos头">DOS头</h3>
<p>微软创建PE文件格式时，人们正广泛使用DOS文件，所有微软充分考虑了PE文件对DOS文件的兼容性。其结果是在PE头的最前面添加一个<code>IMAGE_DOS_HEADER</code>结构体，用来扩展已有的DOS EXE 头。</p>
<pre><code>代码  IMAGE_DOS_HEADER

typedef struct _IMAGE_DOS_HEADER{
    WOED    e_magic;            //DOS signature :4D5A (&quot;MZ&quot;)
    WOED    e_cblp;
    WOED    e_cp;
    WOED    e_crlc;
    WOED    e_cparhdr;
    WOED    e_minalloc;
    WOED    e_maxalloc;
    WOED    e_ss;
    WOED    e_sp;
    WOED    e_csum;
    WOED    e_ip;
    WOED    e_cs;
    WOED    e_lfarls;
    WOED    e_ovno;
    WOED    e_res[4];
    WOED    e_oemid;
    WOED    e_oeminfo;
    WOED    e_res2[10];
    LONG        e_lfanew;           //offset to NT header
    
}
</code></pre>
<p>IMAGE_DOS_HEADER 结构体的大小为64字节。在该结构体中必须知道2个重要成员：e_magic 与 e_lfanew</p>
<pre><code>e_magic:    DOS签名（signature , 4D5A =&gt; ASCII 值 &quot;MZ&quot;）。
e_lfanew:   指示NT头的偏移（根据不同文件拥有可变值）。
</code></pre>
<p>所有PE文件在开始部分（e_magic）都有 DOS 签名（&quot;MZ&quot;）。e_lfanew 值指向NT 头文件所在位置（NT头的名称为 IMAGE_NT_HEADER）。</p>
<p>使用Hex Editor打开notepad.exe，查看IMAGE_DOS_HEADER结构体，如下所以：</p>
<figure data-type="image" tabindex="2"><img src="https://i.loli.net/2021/08/04/jS9AZOxPhoiRY1H.png" alt="1628070343_1_.jpg" loading="lazy"></figure>
<pre><code>注：一个名叫 Mark Zbikowski的开发人员在微软设计了 DOS 可执行文件，MZ即取自其名字i的首字母
</code></pre>
<p>根据PE规范，文件开始的2个字节为4D5A,e_lfanew值为000000F8(不是F800000)</p>
<pre><code>    Inter系列的CPU以逆序存储数据，这称为小端序标识法。
</code></pre>
<h3 id="dos-存根">DOS 存根</h3>
<p>DOS存根（stub）在DOS头下方，是个可选，切大小不固定（即使没有dos存根，文件也能正常运行）。DOS存根由代码与数据混合而成。下图就是notepad.exe的DOS存根。</p>
<figure data-type="image" tabindex="3"><img src="https://i.loli.net/2021/08/04/QCMkvJ5BhiRbANs.png" alt="ZMGO_3_PGB_REY44_9HKH_L.png" loading="lazy"></figure>
<p>如上图，文件偏移40~4D区域为16位的汇编指令。32位的Windows OS 中不会运行该命令（由于被识别为PE文件，所以完全忽视改代码）。</p>
<h3 id="nt-头">NT 头</h3>
<p>NT头IMAGE_NT_HEADERS结构体</p>
<pre><code>代码    IMAGE_NT_HEADERS
tyupedef    struct  _IMAGE_NT_HEADERS{
        DWORD                       Signature;    //PE Signature : 5045 0000 (&quot;PE&quot; 00)
        IMAGE_FILE_HEADER           FileHeader;
        IMAGE_OPTIONAL_HEADER32     OptionalHeader;
} IMAGE_NT_HEADER32,*PIMAGE_NT_HEADER32;
</code></pre>
<p>IMAGE_NT_HEADERS结构体由3个成员组成，第一个成员为签名（Signature）结构体，其值为50450000h（&quot;PE&quot;00）。另外两个成员分别为文件头（File Header）与可选头（Optional Header）结构体。</p>
<p>IMAGE_NT_HEADERS 结构体的大小为F8，相当大。</p>
<figure data-type="image" tabindex="4"><img src="https://i.loli.net/2021/08/04/VS6edOa3Ki5yHZQ.png" alt="6D9`A0_O3_Z3S_S_9LBTPCY.png" loading="lazy"></figure>
<h3 id="nt头头文件">NT头：头文件</h3>
<p>头文件是表现文件大致属性的IMAGE_FILE_HEADER结构体。</p>
<pre><code>代码

typedef struct _IMAGE_FILE_HEADER{
    WORD    Machine;    
    WORD    NumberOfSections;
    DWORD   TimeDataStamp;
    DWORD   PointerToSymbolTable;
    DWORD   NumberOfSymbols;
    WORD    SizeOfOptionalHeader;
    WORD    Characteristics;
}IMAGE_FILE_HEADER,*PIMAGE_FILE_HEADER;
</code></pre>
<h4 id="machine">Machine</h4>
<p>每个CPU都拥有的唯一Machine码，兼容32位Intel x86 芯片的Machine码位14C。x64: 8664。</p>
<h4 id="numberofsections">NumberOfSections</h4>
<p>NumberOfSections用来指出文件中存在的节区数量。该值一定要大于0，且当定义的节区数量与实际节区不用时，将发生运行错误。</p>
<h4 id="sizeofoptionalheader">SizeOfOptionalHeader</h4>
<p>IMAGE_NT_HEADER结构体的最后一位成员为IMAGE_OPTIONAL_HEADER32 结构体。SizeOfOptionalHeader成员用来指出IMAGE_OPTIONAL_HEADER32结构体的长度。windows PE装载器需要查看IMAGE_FILE_HEADER的SizeOfOptionalHeader值，从而识别出IMAGE_OPTIONAL_HEADER32结构体的大小。</p>
<p>PE32+格式的文件中使用的是IMAGE_OPTIONAL_HEADER64结构体，而不是IMAGE_OPTIONAL_HEADER32结构体。2个结构体的尺寸是不用的，所以需要在SizeOfOptionalHeader成员中明确指出结构体的大小。</p>
<h4 id="characteristics">Characteristics</h4>
<p>该字段用于标识文件的属性，文件是否可以运行的形态、是否为DLL文件等信息，以 bit OR形式组合起来。</p>
<p><strong>IMAGE_FILE_HEADER</strong></p>
<p>在Hex Editor 中查看notepad.exe的IMAGE_FILE_HEADER结构体。<br>
<img src="https://i.loli.net/2021/08/04/9tx3lVD4EwvLnjH.png" alt="BOXBWBMJH1BJ_GAHOAFL~XY.png" loading="lazy"></p>
<h3 id="nt-头-可选头">NT 头： 可选头</h3>
<pre><code>

</code></pre>
<p>在IMAGE_OPTIONAL_HEADER32结构体中需要关注下列成员。这些值是文件运行必需的，设置错误将导致文件无法正常运行。</p>
<h4 id="magic">Magic</h4>
<p>为IMAGE_OPTIONAL_HEADER32结构体时，Magic码为 10B；为IMAGE_OPTIONAL_HEADER64结构体时，Magic码为20B。</p>
<h4 id="addressofentrypoint">AddressOfEntryPoint</h4>
<p>AddressOfEntryPoint 持有EP的RVA值。该值指出程序最先执行的代码起始地址，相当重要。</p>
<h4 id="imagebase">ImageBase</h4>
<p>进程虚拟内存的范围是0~FFFFFFFF(32位系统)。PE文件被加载到如此大的内存中时，ImageBase指出文件的优先装入地址。</p>
<p>EXE、DLL文件被装载到用户内存的0<sub>7FFFFFFF中，SYS文件被载入内核内存的80000000</sub>FFFFFFFF中。执行PE装载器先创建进程，再将文件载入内存，然后把EIP寄存器的值设置为 Image+AddressOfEntryPoint。</p>
<h4 id="sectionalignmentfilealignment">SectionAlignment，FileAlignment</h4>
<p>PE文件的Body部分划分为若干节区，这些节存储着不同类别的数据。FileAlignment指定了节区在磁盘文件中的最小单位，而SectionAlignment则指定了节区在内存中的最小单位（两个参数的值可能相同也可能不同）。磁盘文件或内存的节区的大小必定为FileAlignment或SectionAlignment值的整数倍。</p>
<h4 id="sizeofimage">SizeOfImage</h4>
<p>加载到内存时，SizeOfImage指定了PE Image 在虚拟内存中所占空间的大小。一般而言，文件的大小与加载到内存中的大小时不同的（节区头中定义了各节装载的位置与占有内存的大小）</p>
<h4 id="sizeofheader">SizeOfHeader</h4>
<p>SizeOfHeader 用来指出整个PE头的大小。该值也必须是FileAlignment的整数倍。第一节区所在位置与SizeOFHeaders距开始偏移的量相同。</p>
<h4 id="subsystem">Subsystem</h4>
<p>该Subsystem值用来区分系统驱动文件（<em>.sys）与普通的可执行文件（</em>.exe,*.dll）。对应关系如下。</p>
<table>
<thead>
<tr>
<th>值</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Driver文件</td>
<td>系统驱动（如：ntfs.sys）</td>
</tr>
<tr>
<td>2</td>
<td>GUI文件</td>
<td>控制台窗口（如：notepad.exe）</td>
</tr>
<tr>
<td>3</td>
<td>CUI文件</td>
<td>控制台应用程序（如：cmd.exe）</td>
</tr>
</tbody>
</table>
<h4 id="numberofrvaandsizes">NumberOfRvaAndSizes</h4>
<p>NumberOfRvaAndSizes 用来指定 DataDirectory （IMAGE_OPTIONAL_HEADER32结构体的最后一个成员）数组的个数。虽然结构体定义中明确指出了数组的个数为IMAGE_NUMBEROF_DIRECTORY_ENTRIES(16) ，但是PE装载器通过查看NumberOfRvaAndSizes值来识别数组大小，换而言之，数组的大小也可能不是16。</p>
<h4 id="datadirectory">DataDirectory</h4>
<pre><code>
</code></pre>
<p>其中包含了EXPORT/IMPORT/RESOURCE 、TLS Direction。</p>
<p><strong>IMAGE_OPTIONAL_HEADER</strong></p>
<p>结构如下所示：</p>
<figure data-type="image" tabindex="5"><img src="https://i.loli.net/2021/08/04/143bngmrqu6sdRL.png" alt="UVU1S_KQ1SSDK_6VBKL9__0.png" loading="lazy"></figure>
<h3 id="节区头">节区头</h3>
<p>节区头把各个节区的属性记录在节区头中（节区属性中文件有文件/内存的起始位置、大小、访问权限）。</p>
<p>把PE文件创建成多个节区的结构的好处是，这样可以保证程序的安全性。</p>
<pre><code>IMAGE_SECTION_HEADER //节区头结构体
</code></pre>
<p>IMAGE_SECTION_HEADER结构体的重要成员，如下所示：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>VirtualSize</td>
<td>内存中节区所占大小</td>
</tr>
<tr>
<td>VirtualADdress</td>
<td>内存中节区起始地址（RVA）</td>
</tr>
<tr>
<td>SizeOfRawData</td>
<td>磁盘文件节区所占大小</td>
</tr>
<tr>
<td>PointerToRawData</td>
<td>磁盘文件中节区起始位置</td>
</tr>
<tr>
<td>Characteristics</td>
<td>节区属性（bit OR）</td>
</tr>
</tbody>
</table>
<figure data-type="image" tabindex="6"><img src="https://i.loli.net/2021/08/04/o1au5e4UfiIzJQs.png" alt="`_PEEP_@ZW__MZB_I@~VG97.png" loading="lazy"></figure>
<h3 id="rva-to-raw">RVA to RAW</h3>
<p>PE文件加载到内存时，每个节区都要准确完成内存地址与文件偏移间的映射。这种映射一般称为 RVA to RAW，方法如下：</p>
<ol>
<li>查找RVA所在节区。</li>
<li>使用简单公式计算文件偏移（RAW）。</li>
</ol>
<p>根据IMAGE_SECTION_HEADER结构体。换算公式如下：</p>
<pre><code>    RAW - PointerToRawData = RVA - VirtualAddress
                       RAW = RVA - VirtualAddress + PointerToRawData
</code></pre>
<h3 id="iat">IAT</h3>
<p>IAT (Import Address Table,导入地址表)用来记录程序正在使用哪些库中的哪些函数。</p>
<h4 id="dll">DLL</h4>
<p>DLL（Dynamic Link Library） 动态链接库。</p>
<p>加载DLL的方式有两种：</p>
<ul>
<li>显示加载（Explicit Linking），程序使用DLL时加载，使用完毕后释放内存。</li>
<li>隐式加载（Implicit Linking）, 程序开始时即一同加载DLL，程序终止时再释放占用的内存。</li>
</ul>
<h3 id="image_import_descriptor">IMAGE_IMPORT_DESCRIPTOR</h3>
<p><code>IMAGE_IMPORT_DESCRIPTOR</code> 结构体中记录着PE文件要导入哪些库文件。</p>
<pre><code>Import 导入，向库提供服务（函数）
Export 导出，从库向其他PE文件提供服务（函数）
</code></pre>
<p>执行一个普通程序往往需要多个导入库，导入多少个库就存在多少个  <code>IMAGE_IMPORT_DESCRIPTOR</code> 结构体，这些结构体形成了数组，且结构体数组最后以NULL结构体结束。</p>
<pre><code>重要成员
IMAGE_IMPORT_DESCRIPTOR（20字节）
    
    OriginalFirstThunk（0-3字节）       INT的地址（RVA）
    NAME（12-15字节）                   库名称字符串的地址（RVA）
    FirstThunk（16-19字节）             IAT的地址（RVA）
</code></pre>
<p><code>IMAGE_IMPORT_DESCRIPTOR</code>不在PE头而在PE体中，但是找其位置信息在PE头中，IMAGE_OPTIONAL_HEADER32.DataDirectory[1].VirttualAddress的值即是<code>IMAGE_IMPORT_DESCRIPTOR</code>结构体数组的起始地址（RVA值）。<code>IMAGE_IMPORT_DESCRIPTOR</code>结构体数组也被称为<code>IMPORT Directory Table</code>。</p>
<figure data-type="image" tabindex="7"><img src="https://i.loli.net/2021/08/05/aMSxveT7gJIdONK.png" alt="1628151543_1_.jpg" loading="lazy"></figure>
<p>通过<code>RVA to RAW</code>公式，计算出文件偏移为<code>6A04</code>。</p>
<pre><code>计算过程
    首先 7604（RVA） 在第一节区，故在节区头找到 
        VirtualAddress   = 1000
        PointerToRawData = 400
    则：
        RAW = RVA - VirtualAddress + PointerToRawData
            =6A04
</code></pre>
<p>第一个成员在磁盘文件中的位置为：</p>
<figure data-type="image" tabindex="8"><img src="https://i.loli.net/2021/08/05/RgPj9xzviKO7pL8.png" alt="1628151589_1_.jpg" loading="lazy"></figure>
<p>故第一个<code>IMAGE_IMPORT_DESCRIPTOR</code>结构体数组各个元素如下所示</p>
<pre><code>文件偏移        成员                      RVA         RAW
6A04        OriginalFirstThunk(INT)     00007990    00006D90
6A10            Name                    00007AAC    00006EAC
6A14        FirstThunk(IAT)             000012C4    000006C4
</code></pre>
<h4 id="库名称name">库名称（Name）</h4>
<p>RVA:7AAC -&gt; RAW:6EAC</p>
<figure data-type="image" tabindex="9"><img src="https://i.loli.net/2021/08/05/IFvXQim7sLp1cEd.png" alt="1628151628_1_.jpg" loading="lazy"></figure>
<h4 id="originalfirstthunk-int">OriginalFirstThunk - INT</h4>
<p>INT 是一个包含导入函数信息（Ordinal,Name）的结构体指针数组，只有获得了这些信息才能在加载到进程内存中的库中准确求得相应函数的起始地址。</p>
<p>跟踪<code>OriginalFirstTunk</code>成员<code>RVA:7990 -&gt; RAW:6D90</code></p>
<figure data-type="image" tabindex="10"><img src="https://i.loli.net/2021/08/05/65wvFdSIK9gUakO.png" alt="1628151659_1_.jpg" loading="lazy"></figure>
<p>跟踪数组的第一个值 7A7A(RVA)（RAW:6E7A） ，进入该地址可以看见导入的API函数的名称字符串。</p>
<figure data-type="image" tabindex="11"><img src="https://i.loli.net/2021/08/05/piAgO2JftQl3XVr.png" alt="1628151701_1_.jpg" loading="lazy"></figure>
<h3 id="image_import_by_name">IMAGE_IMPORT_BY_NAME</h3>
<p>7A7A(RVA) -&gt; 6E7A(RAW)</p>
<p>文件偏移的最初的两个字节值（000F）为 <code>Ordinal</code> ，是库中函数的固有编号。<code>Ordinal</code> 的后面为函数名称字符串 <code>PageSetuoDlgw</code>。</p>
<figure data-type="image" tabindex="12"><img src="71146D554F3E4E88B9C97372866CB890" alt="image" loading="lazy"></figure>
<h3 id="firstthunk-iatimport-address-table">FirstThunk - IAT（Import Address Table）</h3>
<p>IAT的RVA：12C4 即为 RAW：6C4</p>
<figure data-type="image" tabindex="13"><img src="https://i.loli.net/2021/08/05/M78s6bJZo9diPAj.png" alt="1628152986_1_.jpg" loading="lazy"></figure>
<p>图中的文件偏移 6C4~6EB区域即为IAT数组区域，对应comdlg32.dll库。它与INT类似，有结构体指针数组组成，且以NULL结尾。</p>
<p>IAT的第一个元素值被编码为76324906，该值没有实际意义，notepad.exe文件加载到内存时，准确的地址值会取代该值。它是API的准确的起始地址。</p>
<h2 id="eat">EAT</h2>
<p>EAT 是一种核心机制，它使得不同的应用程序可以调用库文件中提供的函数。</p>
<p>PE文件中仅有一个用来说明库EAT的<code>IMAGE_EXPORT_DIRECTORY</code>结构体。</p>
<p>可以在PE文件的PE头中查找到<code>IMAGE_EXPORT_DIRECTORY</code>结构体的位置。<code>IMAGE_OPTIONAL_HEADER32.DataDirectory[0].VirtualAddress</code>值即是<code>IMAGE_EXPORT_DIRECTORY</code>结构体数组的起始地址（也是RVA的值）。</p>
<figure data-type="image" tabindex="14"><img src="https://i.loli.net/2021/08/05/4saoCwW3EfbtG1y.png" alt="1628151770_1_.jpg" loading="lazy"></figure>
<p>第一个4字节为VirtualAddress，第2个四字节为Size成员。</p>
<h3 id="image_export_directory">IMAGE_EXPORT_DIRECTORY</h3>
<pre><code>IMAGE_EXPORT_DIRECTORY (40字节)
    NumberOfFunctions（20-23字节）  实际导出函数个数
    NumberOfNames   （24-27字节）   Export函数中具名的函数个数
    AddressOfFunctions（28-31字节） Export函数地址数组
    AddressOfNames  （32-35字节）   函数名称地址数组
    AddressOfNameOrdinals(36-39字节)Ordinal地址数组
</code></pre>
<h3 id="练习">练习</h3>
<p>从<code>kernel32.dll</code>文件的EAT中查找<code>AddAtomW</code>函数</p>
<figure data-type="image" tabindex="15"><img src="https://i.loli.net/2021/08/05/Zty6j2sgPoUzVEK.png" alt="1628151808_1_.jpg" loading="lazy"></figure>
<figure data-type="image" tabindex="16"><img src="https://i.loli.net/2021/08/05/1ByzflouFQvpM2O.png" alt="1628151849_1_.jpg" loading="lazy"></figure>
<p>由图可知<code>IMAGE_EXPORT_DIRECTORY</code>结构体的RAW为 1A2C 。</p>
<figure data-type="image" tabindex="17"><img src="https://i.loli.net/2021/08/05/hGpTrtXFVOkbzuJ.png" alt="1628151891_1_.jpg" loading="lazy"></figure>
<pre><code>文件偏移        成员                值          RAW
1A38            Name               00004B8E     3F8E   
1A40         NumberOfNames         0000039B     ----
1A44         NumberOfFunctions     0000039B     ----
1A48         AddressOfFuntions     00002654     1A54
1A4C          AddressOfNames       00003538     2938
1A50       AddressOfNameOrdinals   0000441C     381C
</code></pre>
<h4 id="函数名称数组">函数名称数组</h4>
<p><code>AddressOfNames</code>成员的值为： RVA = 3538,即 RAW = 2938 。</p>
<figure data-type="image" tabindex="18"><img src="https://i.loli.net/2021/08/05/lJUa2ceHbRFMvk8.png" alt="1628151927_1_.jpg" loading="lazy"></figure>
<p>此处为4字节RVA组成的数组。数组元素个数为NumberOfNames（39B）逐一跟随所有的RVA值即可发现函数名称字符串</p>
<h4 id="查找指定的函数名称">查找指定的函数名称</h4>
<p>要查找函数名称字符串为“AddAAtomW”，只要在找到第三个元素的值即可（RVA：004BBC -&gt; RAW：3FBC）</p>
<figure data-type="image" tabindex="19"><img src="https://i.loli.net/2021/08/05/NeG1JDkiXTtUzSV.png" alt="1628151976_1_.jpg" loading="lazy"></figure>
<figure data-type="image" tabindex="20"><img src="https://i.loli.net/2021/08/05/NdXJPf9Q5iHMKF8.png" alt="1628152013_1_.jpg" loading="lazy"></figure>
<h2 id="自己的一些心得笔记">自己的一些心得笔记</h2>
<pre><code>dos头大小为64字节（40h）
    e_lfanew（倒数4个字节）  成员值是NT头的偏移，即 IMAGE_NT_HEADER 的起始位置。

NT头文件大小为 20（14h） 字节
    NumberOfSections(3，4字节)          节区的个数
    SizeOfOptionHeader（16，17字节）    可选头大小
    
    注：e_lfanew + 18h(Signature(4h)+NT_HEADER_FILE(14h)) + SizeOfOptionHeader =  IMAGE_SECTION_HEADER 偏移
    
IMAGE_OPTIONAL_HEADER  NT可选头
    AddressOfEntryPoint（17-20字节）    起始代码入口点
    ImageBase (29-32字节)               PE文件装入内存时，文件的优先装入位置。
    SizeOfheaders（61-64字节）      指出PE头大小，即第一节区所在的位置。
    
IMAGE_SECTION_HEADER (40字节) 节区头
    8-11字节：VirtSize              内存中节区所占大小
    VirtualAddress（12-15字节）     内存中节区的起始地址
    SizeOfRawData（16-19字节）      磁盘文件中节区所占大小
    PointerToRawData（20-23字节）   磁盘文件中节区起始位置
</code></pre>
]]></content>
    </entry>
</feed>